// ==== Callbacks ====  

/* Step 1: Create a higher-order function
  * Create a higher-order function named consume with 3 parameters: a, b and cb
  * The first two parameters can take any argument (we can pass any value as argument)
  * The last parameter accepts a callback
  * The consume function should return the invocation of cb, passing a and b into cb as arguments
*/

function consume(a, b, cb) {
  return cb(a, b);
}

/* Step 2: Create several functions to callback with consume();
  * Create a function named add that returns the sum of two numbers
  * Create a function named multiply that returns the product of two numbers 
  * Create a function named greeting that accepts a first and last name and returns "Hello first-name last-name, nice to meet you!"
*/

const add = function(a, b) {
  return a + b;
}

const multiply = function(a, b) {
  return a * b;
}

const greeting = function(a, b) {
  return `Hello ${a} ${b}, nice to meet you!`
}

/* Step 3: Check your work by un-commenting the following calls to consume(): */
console.log(consume(2, 2, add)); // 4
console.log(consume(10, 16, multiply)); // 160
console.log(consume("Mary", "Poppins", greeting)); // Hello Mary Poppins, nice to meet you!


// ==== Closures ==== 

// Explain in your own words why nestedfunction can access the variable internal.

// Explanation:
 
/*

!!! WARNING:  VERBOSE AND MOST LIKELY FLAWED EXPLANANTION AHEAD !!!

First, an explanation of closures in general:

To understand closures, first we need to talk about the lexical environment and the environmental record.  The lexical environment is created when the code is ran.  Every block of code in the outer lexical scope generates a piece of the lexical environment that is stored on the environmental record at the time of compiling.  The environmental record is an object that stores all local variables and all intializations of functions in the outer scope as it's properties.  For example, if we wrote: 

let phrase= 'Hello' 

the lexical environment created would be:

phrase = 'Hello' 

and this lexical environment would be stored as a property on the environmental record.  The lexical environemt that belongs to the environmental record is the 'outer' lexical environment.  When we  declare a function said function is fully initialized when the lexical environment is generated.  For example, if we declared a function that used the variable we just made:

function say() { 
   return phrase; 
} 

The outer lexical environment that is generated by the function, to be stored on the environmental record, would first, due to hoisting, be: 

say: function

and would return null since the compiler hasn't yet reached the variable being accessed by the function.  Then as the compiled cascades down and it gets to our 'phrase' variable, the actual lexical environment would be:

say: function
phrase: 'Hello'

Because both the function and the variable exist on the outer lexical environment together, the function has access to the variable.  This means that the inner lexical environment of the function where its code is written has access to the outer lexical environment where the variable exists. Conversely, when we write a function an INNER lexical environment is created that acts in an identical fashion.  It logs the variables inside the function and if there are nested functions, initializes them.  The lexical scope of the outer, or parent function, CLOSES around the lexical environment that is created inside it.  The relationship repeats as above just on a smaller context.  Because the compiler initializes the functions right off the bat, a function cannot reach inward from the global lexical scope to the inner lexical scope.  But if a function is initialized on the same lexical scope as a variable it can access that variable.  If the function that creates the inner lexical scope doesn't contain the variable then the enclosed function will reach outside the inner lexical scope and look in the next one up, continuing until it either reaches the variable it's looking for or ultimately reaching the global scope where the search will end.  Due to the compiler initializing all functions at time of compiling the lexical scope is basically set in stone and thus functions on a higher scope cannot reach inward to the inner lexical environment(s). 



As it pertains to the function below:

The variable eternal and myFunction exist in the global, or outer, lexical environment as properties on the environmental record.  When the compilper runs it will hoist myFunction, initialize it and return null.  Then as the compiler cascades down it will see const eternal and log it into said environmental record.  The nested function will be initialized as well, but it exists inside the inner lexical environment created by myFunction.  Because the compiler initializes all functions at the time of compiling functions only have access to variables either inside the lexical scope in which they exist and the variables that exist in lexical environments outside of their own.
*/


const external = "I'm outside the function";

function myFunction() {
  console.log(external);
  const internal = "Hello! I'm inside myFunction!";

  function nestedFunction() {
    console.log(internal);
  };
  nestedFunction();
}
myFunction();
